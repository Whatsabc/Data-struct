//你好
#include<stdio.h>
using namespace std;
#define MVNum 100//?????????

typedef struct ArcNode//????
{
	int adjvex;//???????????????;
	struct ArcNode *nextarc;//??????????????
	OtherInfo info;//????????????
}ArcNode;

typedef struct VNode//?????????
{
	VerTexType data;
	ArcNode *firstarc;//?????????????????????
}VNode,AdjList[MVNum];//????????????

typedef struct
{
	AdjList vertices;//?????????
	int vexnum, arcnum;//??????????????????
}ALGraph;

int main()
{

}


int CreateUDG(ALGraph &G)
{
	cin>>G.vexnum>>G.arcnum;
	for(i=0;i<G.vexnum;i++)
	{
		cin>>G.veretices[i].data;
		G.vertices[i].firstarcs=NULL;
	}
	for(k=0;k<G.arcnum,k++)
	{
		cin>>v1>>v2;
		i=LocateVex(G,v1);
		j=LocateVex(C,v2);
		p1=new ArcNode;
		p1->adjvex=j;
		p1->nextarc=G.vertices[i].firstarc;G.vertices[i].firstarc=p1;
		p2=new ArcNode;
		p2->adjvex=i;
		p2->nextarc=G.vertices[j].firstarc;G.vertices[j].firstarc=p2;
		//??????????????????
	}
return 1;
}

//????????????
#define MAX_VERTEX_NUM 20
typedef struct ArcBox{
	int tailvex,headvex;
	struct ArcBox *hlink,*tlink;
	InfoType *info;
}ArcBox;

//???????
struct{
	VerTexType adjvex;
	ArcType lowcost;
}closedge[MVNum];
void MiniSpanTree_Prim(AMGraph G,VerTexType u)
{
	k=LocateVex(G,u);
	for(j=0;j<G.vexnum;j++)
		if(j!=k)
		closedge[j]={u,G.arcs[k][j]};
	closedge[k].lowcost=0;
	for(i=0;i<G.vexnum;i++)
	{
		k=Min(closedge);
		u0=closedge[k].adjvex;
		v0=G.vexs[k];
		cout<<u0<<v0;
		closedge[k].lowcost=0;
		